---
import { Image } from "astro:assets";
import { actions } from "astro:actions";
import { getFormatedTime } from "@/lib/helpers";
import { DiscIcon, MicVocalIcon, SquarePauseIcon } from "@lucide/astro";
import BlockIcon from "@/assets/icons/timeline_block.svg";

const { data, error } = await Astro.callAction(actions.spotify.requestData, {});

const realProgress = (() => {
	if (!data?.progress_ms) {
		return 0;
	}
	const calc = data.progress_ms + (Date.now() - data.fetched_at);
	return Math.min(calc, data.song.duration_ms);
})();
---

{data ? (
	<div class="song-display cflex" data-online={data.is_playing}>
		<div class="cover-wrapper">
			<Image
				class="song-cover"
				src={data.song.album.images[0].url}
				width={data.song.album.images[0].width}
				height={data.song.album.images[0].height}
				alt="The album cover of the currently playing song."
			/>
		</div>
		<div class="song-information-wrapper">
			<span class="song-title">
				<a href={data.song.external_urls.spotify} target="_blank">
					{data.song.name}
				</a>
			</span>
			<MicVocalIcon class="mic-svg" />
			<span class="artists-wrapper">
				{data.song.artists.map((artist, index) => (
					<>
						<a class="artist" href={artist.external_urls.spotify} target="_blank">
							{artist.name}
						</a>
						{index < data.song.artists.length - 1 && <span> • </span>}
					</>
				))}
			</span>
			<DiscIcon class="disc-svg" />
			<span class="album-wrapper">
				<a href={data.song.album.external_urls.spotify} target="_blank">
					{data.song.album.name}
				</a>
			</span>
			<SquarePauseIcon class="pause-icon" />
			<span class="last-played">
				{data.last_played ? `listened ${getFormatedTime(data.last_played)} ago` : "paused"}
			</span>
		</div>
		<div class="timeline">
			<div class="bar">
				{Array.from({length: 32}).map(() => (
					<BlockIcon class="block" />
				))}
			</div>
			<div class="timecodes rflex">
				<span data-progress_ms={realProgress} class="progress">0:00</span>
				<span data-duration_ms={data.song.duration_ms} class="duration">0:00</span>
			</div>
		</div>
	</div>
) : (
	<h2>SpotifyError</h2>
)}

<style>
	@import url("@/styles/songDisplayAngle.css");

	.song-display[data-online="false"] .timeline {
		display: none;
	}

	.song-display {
		gap: var(--size-s);
	}

	.song-information-wrapper {
		display: grid;
		width: 100%;
		grid-template-columns: 24px 1fr;
		gap: var(--size-2xs) var(--size-xs);
	}

	.cover-wrapper {
		position: relative;
		display: flex;
		overflow: visible;
		z-index: 0;
	}

	.song-cover {
		aspect-ratio: 1 / 1;
		width: 100%;
		height: auto;
		border: 2px solid var(--bg);
	}

	.cover-wrapper::after,
	.cover-wrapper::before {
		content: '';
		position: absolute;
		height: 100%;
		width: 100%;
		background-image: conic-gradient(from var(--angle), transparent 70%, var(--primary));
		top: 50%;
		left: 50%;
		translate: -50% -50%;
		z-index: -1;
		padding: 2px;
		animation: borderRotate 6s cubic-bezier(0.55, 0.25, 0.45, 0.75) infinite;
	}

	.song-display[data-online="false"] .cover-wrapper::after,
	.song-display[data-online="false"] .cover-wrapper::before {
		background-image: conic-gradient(from var(--angle), transparent 70%, var(--text-muted));
		animation: borderRotate 12s cubic-bezier(0.55, 0.25, 0.45, 0.75) infinite;
	}

	.cover-wrapper::before {
		filter: blur(.5em);
	}

	/* property angle moved to `src/styles/songDisplayAngle`
			to avoid breaking the code highlighting */
	@keyframes borderRotate {
		0% { --angle: 0deg; }
		100% { --angle: 360deg; }
	}

	.song-title {
		font-size: 1.5em;
		font-weight: 500;
		grid-column: span 2;
		margin-bottom: var(--size-3xs);
	}

	.song-title a {
		color: var(--text);
	}

	.mic-svg, .disc-svg {
		grid-column-start: 1;
	}

	.artists-wrapper, .album-wrapper, .last-played {
		grid-column-start: 2;
		align-content: center;
	}

	.song-information-wrapper svg {
		position: relative;
		aspect-ratio: 1 / 1;
		height: 24px;
		width: auto;
	}

	.last-played {
		font-style: italic;
	}

	.song-display[data-online="false"] .song-cover {
		filter: grayscale();
	}

	.song-display[data-online="false"] .song-title a {
		color: var(--text-muted);
	}

	.song-display[data-online="true"] .pause-icon,
	.song-display[data-online="true"] .last-played {
		display: none;
	}

	.timeline .bar {
		position: relative;
		width: 100%;
		height: var(--size-m);
		border: 1px solid var(--border-muted);
	}

	.timeline .block {
		position: absolute;
		height: calc(var(--size-m) - 6px);
		width: auto;
		stroke: transparent;
		fill: var(--primary);
		top: 2px;
		opacity: 0;
		transition: opacity 500ms ease;
	}

	.timeline .timecodes {
		justify-content: space-between;
		font-size: .75em;
		padding: var(--size-3xs);
	}
</style>

<script>
	import { formatSeconds, getFormatedTime } from "@/lib/helpers";
	import { actions } from "astro:actions";

	const songDisplay = document.querySelector<HTMLDivElement>('.song-display');
	const songCover = document.querySelector<HTMLImageElement>('.song-display .song-cover');
	const songTitle = document.querySelector<HTMLAnchorElement>('.song-display .song-title a');
	const songArtistsWrapper = document.querySelector<HTMLSpanElement>('.song-display .artists-wrapper');
	const songAlbum = document.querySelector<HTMLAnchorElement>('.song-display .album-wrapper a');
	const lastPlayedSpan = document.querySelector<HTMLSpanElement>('.last-played');

	const blockElements = document.querySelectorAll<SVGElement>('.timeline .block');
	const progressSpan = document.querySelector<HTMLSpanElement>('.progress');
	const durationSpan = document.querySelector<HTMLSpanElement>('.duration');

	let progress = new Date(Number(progressSpan?.dataset.progress_ms));
	let duration = new Date(Number(durationSpan?.dataset.duration_ms));

	/**
	 * Updates the SongDisplay with the newest data available.
	 */
	async function updateSongDisplay() {
		const { data, error } = await actions.spotify.requestData();

		if (error) {
			console.log("Error while fetching new song data: " + error);
			return;
		}

		// Timeline data
		progress.setTime((() => {
			if (!data?.progress_ms) return 0;
			const calc = data.progress_ms + (Date.now() - data.fetched_at);
			return Math.min(calc, data.song.duration_ms);
		})());
		duration.setTime(data.song.duration_ms);
		durationSpan!.textContent = `${duration.getMinutes()}:${formatSeconds(duration.getSeconds())}`;

		songDisplay!.dataset.online = String(data.is_playing);

		songArtistsWrapper!.innerHTML = "";

		songCover!.src = data.song.album.images[0].url;
		songCover!.width = data.song.album.images[0].width;
		songCover!.height = data.song.album.images[0].height;

		songTitle!.innerText = data.song.name;
		songTitle!.href = data.song.external_urls.spotify;

		data.song.artists.forEach((artist, index) => {
			const entry = document.createElement('a');
			entry.classList.add('artist');
			entry.innerText = artist.name;
			entry.href = artist.external_urls.spotify;
			entry.target = "_blank";

			songArtistsWrapper?.appendChild(entry);

			if (index < data.song.artists.length - 1) {
				const separator = document.createElement('span');
				separator.innerText = " • ";
				songArtistsWrapper?.appendChild(separator);
			}
		});

		songAlbum!.innerText = data.song.album.name;
		songAlbum!.href = data.song.album.external_urls.spotify;

		lastPlayedSpan!.innerText = !!data.last_played ? `listened ${getFormatedTime(data.last_played)} ago` : "paused";
	}

	/**
	 * Updates the timeline block elements and progress counter.
	 */
	function updateTimeline() {
		if (songDisplay!.dataset.online == "false") return;

		const expectedBlockCount = Math.round(progress.getTime() / duration.getTime() * blockElements.length);

		blockElements.forEach((block, index) => {
			block.style.opacity = (index <= expectedBlockCount) ? '1' : '0';
		});

		// skip counting if song ends
		if (duration.getTime() - progress.getTime() <= 500) {
			return;
		}

		progress.setTime(progress.getTime() + 1000);
		progressSpan!.textContent = `${progress.getMinutes()}:${formatSeconds(progress.getSeconds())}`;
	}

	blockElements.forEach((block, index) => {
		block.style.left = `${index * 6 + 4}px`;
		block.style.filter = `brightness(${0.4 + index * 0.025})`;
	});

	durationSpan!.textContent = `${duration.getMinutes()}:${formatSeconds(duration.getSeconds())}`;

	window.setInterval(updateSongDisplay, 30000);
	window.setInterval(updateTimeline, 1000);
</script>
